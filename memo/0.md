# ページ分割

　markdown風テキストを本のようにページ分割したHTMLに変換する。

　以下プロジェクトにて既に挑戦した。

* https://github.com/ytyaru/Html.ScreenSplit.20231009152356

　上記はプレーンテキストをリアルタイムに解析し、HTMLをDOMとして返却して画面に表示する。

　文量が10万字など膨大になると約一分もかかる。画面サイズ範囲内になるよう繰り返し計算するため膨大な計算量になってしまう。WebWorkerでマルチスレッド化すれば高速化できる可能性もあるが、別のアプローチも模索したい。

1. 時間がかかることを警告しつつ静的HTMLファイルを出力するJS-GUIツール
2. C言語などで実装しCLIで実行してHTMLファイルを出力するツール
3. C言語などでmarkdown風テキストから直接描画するビューアを作る

　画面サイズ範囲内計算はJSでないとできないと思われる。頑張れば何でもできるが、死ぬほど大変なことになる。できるものならブラウザ依存を辞めて独自のビューアアプリを作りたい。ブラウザは他のページとの兼ね合いなどでクラッシュしたり、データが消えたりすることが起きる。責任の分離をするため専用アプリが欲しい。しかし実行環境が限られてしまうネックがある。

　とりあえず最も簡単なJSで実装するものとする。それでも大変そう。

　ページ分割したHTMLデータをどのように出力すべきか。

1. 一つのHTMLファイルにまとめつつ[break-after][]で分割する（ページ毎に`<div style="break-after:page;">`で囲む）
2. ページ数と同じ数だけHTMLファイルを出力する（`1.html`などページ数をファイル名にする）

[break-after]:https://developer.mozilla.org/ja/docs/Web/CSS/break-after

　ヘッダなど共通部分を考慮すると一つのHTMLファイルにまとめたほうがデータ量が少なくなって好ましいと思われる。

　閲覧時はスクロール状態になってしまうと思われる。これをキーやマウスによるページ遷移にするには、どう実装すればいいかが主な問題。

　CSSの`display`を`none`/`block`で切り替えればいいか？

```html
<div class="page" style="visibility:visible;">1ページ目<div>
<div class="page" style="visibility:hidden;">2ページ目<div>
```
```html
<div class="page" style="display:block;">1ページ目<div>
<div class="page" style="display:none;">2ページ目<div>
```

1. 原稿（markdown風テキストファイル）
2. 特定サイズでページ分断位置が入力されたファイル

　1から2を作り、2をビューアで表示すれば、画面サイズや文字サイズに合わせたページ分断処理をせずに済み、高速に表示できる。ただし画面サイズが環境に合致しているかは不明だし、文字サイズも好きに変更したい場合も出てくるだろう。そうすると結局は再計算する羽目になる。

　厄介なことにサイズが変わる要素の一つにフォントがある。フォントは環境毎に違い統一されることはない。OSの経営戦略の一貫だったりライセンス問題などの利権が絡むため。すると環境毎にサイズが代わり、画面内に収まらなくなる場合が発生する恐れがある。

　かといってフォントの有無をブラウザから調べることもできない。セキュリティの事情で。または同じフォントでもOS毎に名前が違うなどが起こりうるため、技術的にフォント名を取得するAPIができたとしても難しい。

　結局は自分の環境で一度ページ分断計算をして、そのデータを保存することで次回以降は計算を省略するという流れになる。

```
前のページ末尾

=== ページ区切

次のページ先頭
```
```
---
title: ...
pager:
  width: 1920px
  height: 1080px
  column: 2
  writing-mode: vertical-rl
  font-family: ''
  font-size: 16px
  letter-space: 0.05em
  line-height: 1.75em
---
```

　こうなると次のようなキャッシュデータが必要になる。

* ローカル環境保存（IndexedDB, LocaleStrage）
	* 作品毎
		* 画面サイズ毎（全画面化／最大化の二種類くらいは必要か）

```
* 作品ID
	* 画面サイズ等の関連データ
		* 改ページ位置（全テキストにおける文字index）
```

　改ページ位置を`---`のように本文内で表記すると修正も面倒そう。なのでヘッダ情報`break-points`にまとめてセットする。

```
---
title: ...
pager:
  width: 1920px
  height: 1080px
  column: 2
  writing-mode: vertical-rl
  font-family: ''
  font-size: 16px
  letter-space: 0.05em
  line-height: 1.75em
  break-points: [55, 107, 508, ...]
---
```

　あとは全画面と最大化など画面サイズなどの違いによるパターンをいくつか持たせればいい。


```
---
title: ...
pager:
  common:
    column: 2
    writing-mode: vertical-rl
    font-family: ''
    font-size: 16px
    letter-space: 0.05em
    line-height: 1.75em
  full:
    width: 1920px
    height: 1080px
    break-points: [55, 107, 508, ...]
  maxed:
    width: 1920px
    height: 956px
    break-points: [44, 88, 307, ...]
---
```

　しかしフォントなど細かく変更したパターンを複数持たせたくなりそうだ。YAML構文の継承が使える。

```
---
title: ...
pager:
  sizePattern:
    full:  &full
      width:1920
      height: 1080
    maxed: &maxed
      width:1920
      height: 956
  pattern: 
    verticalFull: &verticalFull
      <<: *full
      column: 2
      writing-mode: vertical-rl
      font-family: 'Noto Serif JP'
      font-size: 16px
      letter-space: 0.05em
      line-height: 1.75em
    horizontalFull: 
      <<: *verticalFull
      writing-mode: horizontal-tb
    verticalMax: &verticalMax
      <<: *verticalFull
      <<: *maxed
    horizontalMax: &horizontalMax
      <<: *horizontalFull
      <<: *maxed
  full:
    break-points: [55, 107, 508, ...]
  maxed:
    break-points: [44, 88, 307, ...]
---
```

　もうCSSそのままのほうが良い気がする。

```css
:root {
  --writing-mode: vertical-rl;
  --font-size: 16px;
  --color-fg: black;
  --color-bg: white;
  --color-fg-select: white;
  --color-bg-select: blue;
  --color-fg-focus: black;
  --color-bg-focus: #ffcccc;
}
body {
  writing-mode: var(--writing-mode);
  color: var(--color-fg);
  background-color: var(--color-bg);
}
::selection {
  color: var(--color-fg-select);
  background-color: var(--color-bg-select);
}
p {/*, ruby, rp, rt, em*/
  font-family: 'Noto Serif JP';
  font-size: var(--font-size);
  letter-space: 0.05em;
  line-height: 1.75em;
}
h1,h2,h3,h4,h5,h6 {
  font-family: 'Noto Sans JP';
  font-size: calc(var(--font-size)*2);
  font-weight: bold;
  letter-space: 0em;
  line-height: 1em;
}
h2{font-size: calc(var(--font-size)*1.8)}
h3{font-size: calc(var(--font-size)*1.6)}
h4{font-size: calc(var(--font-size)*1.4)}
h5{font-size: calc(var(--font-size)*1.2)}
h6{font-size: calc(var(--font-size)*1)}
kbd {
  letter-space: 0em;
  line-height: 1em;
  border: 1px solid var(--color-fg);
  border-round: calc(var(--font-size)*0.125);
}
pre.code {
  font-family: 'Source Code Pro', 'Noto Sans Mono';
  font-size: var(--font-size);
  letter-space: 0em;
  line-height: 1em;
  writing-mode: horizontal-tb;
}
```

　とにかく描画領域で画面サイズの範囲内に収まるかどうかで判断する。

# 一画面に収まる文章を抽出するために必要な情報

* 対象テキスト(字、改行、パラグラフ、改行指示(強制改頁、分離禁止))
* HTML要素種別(h1〜h6, p, br, ruby, pre, code, ...) 要素ごとに異なるサイズや余白の計算に必要。CSS定義も合わせて。
* 書字方向(horizontal-tb/vertical-rl)
* 段落(column, column-gap)
* 画面サイズ(width/heigth)
* 画面向き(landscape/portrait)
* 文字サイズ(pixcel)
* 字間(em)
* 行間(em)

　フォントによってもサイズが変わってくるかもしれない。できればフォントも合わせたいが難しい。

# 画面構成

```
🕢1☀Ｎ§⚙
```
```
時刻,頁数,本メタ情報,書字方向,ライトモード,設定
```

```
本文
-----------------------------------------------------------------
現在時刻　　現頁数／全頁数　　[☀🌙][NZ][📕][⚙]　　作品名　章名
```

```
現｜本
在｜文
時｜
刻｜
　｜
現｜
頁｜
数｜
／｜
全｜
頁｜
数｜
　｜
☀｜
🌙｜
NZ｜
📕｜
⚙｜
　｜
作｜
品｜
名｜
　｜
章｜
名｜
```

