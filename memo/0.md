# ページ分割

　markdown風テキストを本のようにページ分割したHTMLに変換する。

　以下プロジェクトにて既に挑戦した。

* https://github.com/ytyaru/Html.VanJS.Javel.Parser.20240524100007
* https://github.com/ytyaru/Html.ScreenSplit.20231009152356

　上記はプレーンテキストをリアルタイムに解析し、HTMLをDOMとして返却して画面に表示する。

　文量が10万字など膨大になると約一分もかかる。画面サイズ範囲内になるよう繰り返し計算するため膨大な計算量になってしまう。WebWorkerでマルチスレッド化すれば高速化できる可能性もあるが、別のアプローチも模索したい。

1. 時間がかかることを警告しつつ静的HTMLファイルを出力するJS-GUIツール
2. C言語などで実装しCLIで実行してHTMLファイルを出力するツール
3. C言語などでmarkdown風テキストから直接描画するビューアを作る

　画面サイズ範囲内計算はJSでないとできないと思われる。頑張れば何でもできるが、死ぬほど大変なことになる。できるものならブラウザ依存を辞めて独自のビューアアプリを作りたい。ブラウザは他のページとの兼ね合いなどでクラッシュしたり、データが消えたりすることが起きる。責任の分離をするため専用アプリが欲しい。しかし実行環境が限られてしまうネックがある。

　とりあえず最も簡単なJSで実装するものとする。それでも大変そう。

　アプリ形態としては次の３種類に大別できる。

1. 原稿を入力としリアルタイムで頁分割する動的生成版アプリ（文量次第では頁分割に長大な時間がかかる）
2. 全文やページ遷移機能を持った完全自立型単一HTMLファイル（ページ遷移機能など全ファイルで重複する部分が大量にある）
3. 完全静的HTMLファイル（ヘッダ部分など重複する部分が超大量にあるがJavaScriptが機能せずとも動作できる）

　2,3はHTMLファイルを出力するアプリとして作成することになる。その入力は原稿ファイルで同じ。

　次のようなファイルを入出力として扱うことになりそう。

1. 原稿ファイル
2. 頁分割データファイル
3. 完全動的HTMLファイル
4. 静動複合HTMLファイル
5. 完全静的HTMLファイル

　頁分割したデータをどのように保持するか。

1. 動的（JSメモリ内）
	1. HTML形式のStringリテラル値として保持する
	2. Elementオブジェクトとして保持する（ページ遷移する度に指定オブジェクトをDOMにセットする）
	3. DOMとしてDocumentに挿入した状態で保持する（表示是非はCSSで変える `display:block/none`）
2. 静的（HTMLファイル）
	1. 固定データとして原稿をHTML化し頁分割した要素として書き込む（表示是非はCSSで変える `display:block/none`）
	2. 頁分割せず単一HTMLファイルに全文網羅する（通常通りスクロールして閲覧する）
	3. 章など任意の単位で分割した複数HTMLファイルを生成する（相対パスリンクで次のファイルへ）

　頁分割時間vs環境最適性。毎回頁分割すれば最適な表示ができる代わり時間がかかる。静的HTMLで頁分割を固定化すれば時間はかからないが、閲覧環境に適した頁分割ができる保障はない。

* 当アプリ/
	* works/
		* id/
			* manuscript.jd
			* cache/
				* v1920x1080c1f16.html（縦書き,全画面,column-count:1,font-size:16）
				* v1920x956c1f16.html（縦書き,最大化,column-count:1,font-size:16）
				* h1920x1080c2f16.html（横書き,全画面,column-count:2,font-size:16）
				* h1920x956c2f16.html（横書き,最大化,column-count:2,font-size:16）
			* ver/
				* ver1.0.zip（フォント等のバイナリデータやソースコードさえも含めた完全独立版）

　それぞれの実行環境で最適化したcacheファイルを作成し、次回以降はそれを開くことで頁分割計算を省きたい。

　もし自分の環境以外に作品を公開し渡したいなら、そのcacheを作成して快適に閲覧できる機能を含めたzipファイルを配る。

　当アプリは原稿やzipから閲覧可能なHTMLを動的生成し、静的生成もして、可能なら静的生成ファイルをロードするものとしたい。どう考えてもJavaScriptでは厳しい。セキュリティ上ローカルファイルアクセス制限があるから。

　cacheをそのまま配布してもいいが、閲覧環境が限られているため破綻した状態になりかねない。どのような条件で頁分割計算されたのかは、CSSで定義できると思われる。そこから自分の閲覧環境との差異を抽出し、完全に合致している場合のみ閲覧できるようにしたい。もし違えば原稿から動的生成させる。

　あるいは一章毎にファイル分割することで文量を減らし、頁分割計算にかかる時間を減らせば、動的生成しても問題ない。このとき、どのように一つの原稿ファイルとしてまとめつつ、複数回の頁分割計算にするかが問題となる。分割単位を一冊としたとき、ファイル全体で何冊分あるか、それぞれ何文字分のボリュームがあるかを、どうやって計算せず算出するかも。全体の頁数を計算するには頁分割計算が必要であり時間がかかる。ファイル分割しないと負荷分散にならない。

　ではファイル分割した時、どうやってそれを一種類の同じ作品の連続した章であると紐付けるか。zipファイルにまとめて各章を一つの連番ファイルにする。ファイル数と、ファイル毎の字数で全体のボリュームを知れる。ただしページ数だけは画面サイズなどによって変わるため頁計算が必要になり時間がかかる。つまり`全99999字`、`N章55555字`、`現在 1/7章 5/33頁`のような形になる。このとき`頁`はあくまで一ファイル、一つの章における数である。全体のページ数は不明だ。

　頁数は相対値である。画面や文字サイズによって変わるため絶対値ではない。自分と同じ環境内でしか使えない相対的な指標に過ぎない。もし他人に対して特定の場所を示すなら他の指標が必要だ。たとえば原稿の最初から数えて何文字目などの絶対値が必要である。できればそれを入力としてページ遷移できる機能も欲しい。作品の版数(リビジョン値)と合わせる必要がある。

　原稿を外部ファイルから読むとき、任意のファイルを取得する方法は手動によるドラッグ＆ドロップになるだろう。しかし一作品の一章毎にDnDをせねばならぬのは面倒すぎる。やはり一作品を単一ファイルとしてまとめたい。そして頁計算する単位だけは一章毎にして、せいぜい二万字程度に納めれば、頁計算にかかる時間も少なくできるはず。これにてリアルタイムな動的変更が可能になり、縦書き／横書き、文字サイズ、フォントファミリ、ルビON/OFF、白黒などを動的変更できるようになるだろう。

　作品を区切る方法は大きく分けて二種類ある。内容を意味的に構造化した章立てと、現実の物理問題による文量分割した冊子化だ。一つの作品は長大であり、一冊の本に収めることは困難。よって10万字を文庫本一冊にまとめ巻とし、それを複数巻発行することで一つの作品を語る。

1. 分割方法
	1. 意味的構造化（三幕構成をもつ最小単位）
	2. 物量的構造化（閲覧品質と実行速度のトレードオフをした分割単位）

　電子化においてもこの分類方法が必要になる。特に現実の物理問題として文量分割が必要になる。頁分割計算によって表示までの時間がかかるから、抑えるために文量を細かく分割する必要がある。本で例えるなら、読者の手の大きさに合わせて最適なサイズの本になるが、そのための計算処理に時間がかかる状態だ。

　小説において両者の分割を両立する文字数は二万字あたりになる。一章あたりの文字数であり、パフォーマンス問題も解決できるであろうラインは二万字くらいだろう。

　もし原稿なら次のように書く。

```
# 一章 タイトル

　二万字くらい。

# ニ章 タイトル

　二万字くらい。
```

　一章をさらに細かい`項`の単位で分割してもいい。四千字くらいになる。日本人が日本語を読む時、一分あたり四百字なので、四千字なら十分間で読める計算だ。

　もし画面サイズが1920x1080で、縦書きで、文字サイズが24pxなら、一行あたり45字になる。日本語は一行あたり40字程度が読みやすいとされる。作文用紙も40字である。余白、字間、ヘッダ等も考えてこの程度が妥当だろう。これを行間ゼロだと80行になる。実際は1.7em程度が見やすいから一行あたり40.8pxになる。つまり約47行程度。一画面あたり一行40字程度で47行程度になる。40*47=1880字。一画面で1880字となる。実際は改行などもあるからもっと少なくなる。一章あたり二万なので10頁以上になるだろう。

　もしスマホなど画面サイズが小さければ、さらに頁数が増える。処理速度も遅いため、頁分割処理する単位を章でなく項にしたくなるかもしれない。それをアプリが画面サイズから自動的に決定してくれても良さそうだ。このとき現在位置は`1/7章 1/5項 1/21頁`となる。全体のページ数を計測すると時間がかかるとはいえ、流石に三項目に分割して数値化されるとウザい。全体の何％かを一つの数で出して欲しいくらいだ。現在まで閲覧した文字数を全体の文字数で割れば比率が出せるので可能だろう。あるいは読了字数や未読字数として表示してもいい。

```
# 一章 タイトル

## 一項

　四千字くらい。

## ニ項

　四千字くらい。

## 三項

　四千字くらい。

## 四項

　四千字くらい。

## 五項

# ニ章 タイトル

　二万字くらい。

```

　意味的構造化は上記のように原稿で可能だ。しかし物量的構造化は画面サイズなど環境によって変わる。ここが最大の問題だ。一つの原稿ファイルにおいて全頁分割をすると長大な時間がかかってしまう。

　ページ分割したHTMLデータをどのように出力すべきか。

1. 一つのHTMLファイルにまとめつつ[break-after][]で分割する（ページ毎に`<div style="break-after:page;">`で囲む）
2. ページ数と同じ数だけHTMLファイルを出力する（`1.html`などページ数をファイル名にする）

[break-after]:https://developer.mozilla.org/ja/docs/Web/CSS/break-after

　ヘッダなど共通部分を考慮すると一つのHTMLファイルにまとめたほうがデータ量が少なくなって好ましいと思われる。

　閲覧時はスクロール状態になってしまうと思われる。これをキーやマウスによるページ遷移にするには、どう実装すればいいかが主な問題。

　CSSの`display`を`none`/`block`で切り替えればいいか？

```html
<div class="page" style="visibility:visible;">1ページ目<div>
<div class="page" style="visibility:hidden;">2ページ目<div>
```
```html
<div class="page" style="display:block;">1ページ目<div>
<div class="page" style="display:none;">2ページ目<div>
```

1. 原稿（markdown風テキストファイル）
2. 特定サイズでページ分断位置が入力されたファイル

　1から2を作り、2をビューアで表示すれば、画面サイズや文字サイズに合わせたページ分断処理をせずに済み、高速に表示できる。ただし画面サイズが環境に合致しているかは不明だし、文字サイズも好きに変更したい場合も出てくるだろう。そうすると結局は再計算する羽目になる。

　厄介なことにサイズが変わる要素の一つにフォントがある。フォントは環境毎に違い統一されることはない。OSの経営戦略の一貫だったりライセンス問題などの利権が絡むため。すると環境毎にサイズが代わり、画面内に収まらなくなる場合が発生する恐れがある。

　かといってフォントの有無をブラウザから調べることもできない。セキュリティの事情で。または同じフォントでもOS毎に名前が違うなどが起こりうるため、技術的にフォント名を取得するAPIができたとしても難しい。

　結局は自分の環境で一度ページ分断計算をして、そのデータを保存することで次回以降は計算を省略するという流れになる。

```
前のページ末尾

=== ページ区切

次のページ先頭
```
```
---
title: ...
pager:
  width: 1920px
  height: 1080px
  column: 2
  writing-mode: vertical-rl
  font-family: ''
  font-size: 16px
  letter-space: 0.05em
  line-height: 1.75em
---
```

　こうなると次のようなキャッシュデータが必要になる。

* ローカル環境保存（IndexedDB, LocaleStrage）
	* 作品毎
		* 画面サイズ毎（全画面化／最大化の二種類くらいは必要か）

```
* 作品ID
	* 画面サイズ等の関連データ
		* 改ページ位置（全テキストにおける文字index）
```

　改ページ位置を`---`のように本文内で表記すると修正も面倒そう。なのでヘッダ情報`break-points`にまとめてセットする。

```
---
title: ...
pager:
  width: 1920px
  height: 1080px
  column: 2
  writing-mode: vertical-rl
  font-family: ''
  font-size: 16px
  letter-space: 0.05em
  line-height: 1.75em
  break-points: [55, 107, 508, ...]
---
```

　あとは全画面と最大化など画面サイズなどの違いによるパターンをいくつか持たせればいい。


```
---
title: ...
pager:
  common:
    column: 2
    writing-mode: vertical-rl
    font-family: ''
    font-size: 16px
    letter-space: 0.05em
    line-height: 1.75em
  full:
    width: 1920px
    height: 1080px
    break-points: [55, 107, 508, ...]
  maxed:
    width: 1920px
    height: 956px
    break-points: [44, 88, 307, ...]
---
```

　しかしフォントなど細かく変更したパターンを複数持たせたくなりそうだ。YAML構文の継承が使える。

```
---
title: ...
pager:
  sizePattern:
    full:  &full
      width:1920
      height: 1080
    maxed: &maxed
      width:1920
      height: 956
  pattern: 
    verticalFull: &verticalFull
      <<: *full
      column: 2
      writing-mode: vertical-rl
      font-family: 'Noto Serif JP'
      font-size: 16px
      letter-space: 0.05em
      line-height: 1.75em
    horizontalFull: 
      <<: *verticalFull
      writing-mode: horizontal-tb
    verticalMax: &verticalMax
      <<: *verticalFull
      <<: *maxed
    horizontalMax: &horizontalMax
      <<: *horizontalFull
      <<: *maxed
  full:
    break-points: [55, 107, 508, ...]
  maxed:
    break-points: [44, 88, 307, ...]
---
```

　もうCSSそのままのほうが良い気がする。

```css
:root {
  --writing-mode: vertical-rl;
  --font-size: 16px;
  --color-fg: black;
  --color-bg: white;
  --color-fg-select: white;
  --color-bg-select: blue;
  --color-fg-focus: black;
  --color-bg-focus: #ffcccc;
}
body {
  writing-mode: var(--writing-mode);
  color: var(--color-fg);
  background-color: var(--color-bg);
}
::selection {
  color: var(--color-fg-select);
  background-color: var(--color-bg-select);
}
p {/*, ruby, rp, rt, em*/
  font-family: 'Noto Serif JP';
  font-size: var(--font-size);
  letter-space: 0.05em;
  line-height: 1.75em;
}
h1,h2,h3,h4,h5,h6 {
  font-family: 'Noto Sans JP';
  font-size: calc(var(--font-size)*2);
  font-weight: bold;
  letter-space: 0em;
  line-height: 1em;
}
h2{font-size: calc(var(--font-size)*1.8)}
h3{font-size: calc(var(--font-size)*1.6)}
h4{font-size: calc(var(--font-size)*1.4)}
h5{font-size: calc(var(--font-size)*1.2)}
h6{font-size: calc(var(--font-size)*1)}
kbd {
  letter-space: 0em;
  line-height: 1em;
  border: 1px solid var(--color-fg);
  border-round: calc(var(--font-size)*0.125);
}
pre.code {
  font-family: 'Source Code Pro', 'Noto Sans Mono';
  font-size: var(--font-size);
  letter-space: 0em;
  line-height: 1em;
  writing-mode: horizontal-tb;
}
```

　とにかく描画領域で画面サイズの範囲内に収まるかどうかで判断する。

　いずれにせよ原稿ファイル全体で一括して頁分割計算するのは長大な時間がかかる。これを分散するには原稿によって予め行われた意味的構造化の単位毎に頁分割すると良い。ただし作品全体における頁数は不明のままだ。それでも原稿から全体の文字数と、現在表示している位置までの文字数（読了字数）は判るはずだから、進捗状況は把握できるはずだ。または未読字数を出してもいい。次頁以降の字数を`あとnnnn字`などで表す。

# 一画面に収まる文章を抽出するために必要な情報

* 対象テキスト(字、改行、パラグラフ、改行指示(強制改頁、分離禁止))
* HTML要素種別(h1〜h6, p, br, ruby, pre, code, ...) 要素ごとに異なるサイズや余白の計算に必要。CSS定義も合わせて。
* 書字方向(horizontal-tb/vertical-rl)
* 段落(column, column-gap)
* 画面サイズ(width/heigth)
* 画面向き(landscape/portrait)
* フォント
* 文字サイズ(pixcel)
* 字間(em)
* 行間(em)

　フォントによってもサイズが変わってくるかもしれない。できればフォントも合わせたいが難しい。OS毎に差別化して経営戦略の一貫にしている節がある。ライセンスなどの利権問題も絡んでくる。

```
display:[none|block|inline|inline-block|flex|inline-flex|grid|inline-grid|flow-root|table|table-row|list-item|...]
break-[after|before|inside|]

box-sizing: 
width
height
inline-size
block-size

margin

border

font-family
font-size
font-stretch
font-style
font-variant
font-weight
line-height

writing-mode: vertical-rl; / horizontal-tb;
text-orientation: upright; / mixed;
text-combine-upright: all;
text-emphasis: filled sesame #f00;

column-count: 2; /* 段数 */ 
column-gap

```

# 画面構成

```
🕢1☀Ｎ§⚙
```
```
時刻,頁数,本メタ情報,書字方向,ライトモード,設定
```

```
本文
-----------------------------------------------------------------
現在時刻　　現頁数／全頁数　　[☀🌙][NZ][📕][⚙]　　作品名　章名
```

```
現｜本
在｜文
時｜
刻｜
　｜
現｜
頁｜
数｜
／｜
全｜
頁｜
数｜
　｜
☀｜
🌙｜
NZ｜
📕｜
⚙｜
　｜
作｜
品｜
名｜
　｜
章｜
名｜
```

## 規模

　原稿から作品の規模を把握する方法を網羅する。

　全体の頁数を計算するのは長大な時間がかかる。画面サイズ等によって結果も変わる。

* 字数
	* 全字数: `99,999,999字` / `9万5千字` / `9.5万字`
	* 既読字数: `99,999,999既読字` / `9万5千既読字` / `9.5万既読字`
	* 未読字数: `99,999,999未読字` / `9万5千未読字` / `9.5万未読字` / `あと9.5万字` / `残9.5万字`
	* 既読率: `99.99％既読`
	* 未読率: `99.99％未読`
* 意味的構造化
	* 題,部,章,節,項,目（法律:編,章,節,款,目）(条文:条,項,号)
		* 三段階までに収めたほうが見やすい（多すぎると見づらい）
		* `1/21頁`
		* `1/5節 1/21頁`
		* `1/5章 1/333頁`
		* `1/5章 1/5節 1/21頁`
* 合計
	* これまでの頁数を合計して全体のうち現在頁数だけは出せる（ただし先にある頁数までは出せない）
* 複合
	* `99.99%既読 残9.5万字 1/5章1/5節1/21頁`
	* `1/21頁1/5節1/5章 あと9.5万字 99.99%既読`
	* `1/21-1/5-1/5 9.5万字 99.99%済`
	* `1/21`（クリックすると要約／詳細が切り替わる）
	* `44`（これまでの頁数を合計した全体のうちの現在頁数。クリックすると現在節内頁数`1/21`に切り替わる）

　進捗状況は不明で構わない場合。全体の頁数など知らなくていい。全体における現在の頁数だけ知れたらいい。最も単純な頁数の示し方。厄介なのは全体の頁数は最終頁を閲覧しないと不明であること。

　とりあえず現在の範囲内における頁数さえ知れれば十分。ただし最終頁に到達しても終わるとは限らないため、詳細が知りたければクリックすること。

　進捗状況は全体の字数から概算できる。`99.99%`等の比率または`あと9.5万字`のように字数で明示できる。ただし頁数では示せない。その計算に時間がかかるから。

## 閲覧

　原稿データを渡せばいいだけ。あとはアプリが最適化して表示する。

GET 
```
https://javel.app/index.html?data64=base64文字列...
```
POST
```javascript
JaDoc.viewer.request({manuscript:'原稿'}); // HTML
```

UI
```html
<textarea id="manuscript">原稿</textarea>
```

App
```javascript
https://javel.app/index.html?data64=base64文字列...
```

LIB
```javascript
JaDoc.toDOM({script:'原稿'}); // DOM Element
JaDoc.toHTML({script:'原稿'}); // String
JaDoc.download({script:'原稿'}); // HTML file
```

　原稿はテキストであり、それをCompression Streams APIで圧縮し、Base64 URL Encoding化し、URLパタメータに付与する。

https://168iroha.net/blog/article/202401031600/

まだ東京で摩耗しているの？
まだ社会で摩耗しているの？
まだ企業で摩耗しているの？
まだ労働で摩耗しているの？
まだ義務で摩耗しているの？
まだ金銭で摩耗しているの？
まだ人生で摩耗しているの？
まだ小説投稿サイトで摩耗しているの？

# PageMaker

# 一画面に収まる文章を抽出するために必要な情報

* 対象テキスト(字、改行、パラグラフ、改行指示(強制改頁、分離禁止))
* HTML要素種別(h1〜h6, p, br, ruby, pre, code, ...) 要素ごとに異なるサイズや余白の計算に必要。CSS定義も合わせて。
* 書字方向(horizontal-tb/vertical-rl)
* 段落(column, column-gap)
* 画面サイズ(width/heigth)
* 画面向き(landscape/portrait)
* 文字サイズ(pixcel)
* 字間(em)
* 行間(em)

　フォントによってもサイズが変わってくるかもしれない。できればフォントも合わせたいが難しい。



# 工程

　画面構成。

* 対象テキスト(字、改行、パラグラフ、改行指示(強制改頁、分離禁止))
* HTML要素種別(h1〜h6, p, br, ruby, pre, code, ...) 要素ごとに異なるサイズや余白の計算に必要。CSS定義も合わせて。
* 書字方向(horizontal-tb/vertical-rl)
* 段落(column, column-gap)
* 画面サイズ(width/heigth)
* 画面向き(landscape/portrait)
* 文字サイズ(pixcel)
* 字間(em)
* 行間(em)

　画面サイズに応じて読みやすくする。一行あたり40字、字間0.05em、行間1.7emなどを目安に。

1. テキストエディタで原稿を書く
2. ビューアに渡す
3. 閲覧する

　原稿を作成するときは専用のエディタが欲しい。

1. 原稿の作成
	1. 意味的構造化
	2. 物量的構造化から見た警告（一章あたり2〜2.5万字、一項あたり4〜5千字。一巻あたり4〜6章。）
	3. 原稿の版数管理（version,revision）
	4. 画面構成の設定（著者が確認した表示設定。writing-mode, font-size, color, ...）

　物量的構造化が最適化されていればcacheを作る必要はない。しかし環境によってはcacheにしたい場合もありうる。

* 当アプリがない環境でも最高品質で閲覧したい
* オフラインで閲覧したい（WebWorker,fetch,`<a>`等が使えずとも閲覧したい）
* JavaScriptを使わず閲覧したい（スクロールでいいか、頁分割したいか）

　なるだけ叶えるためにcacheを作れたほうがいい。

1. cacheの作成
	1. 画面構成の設定
	2. 原稿の流し込み
	3. cacheファイル出力

　突き詰めるとブラウザでは限界があるため専用ビューアが欲しい。

　たとえば次のような問題はブラウザで解決できない。

* 完全にネットワークから切り離されたセキュアな状態を保ちたい
* ローカルファイルに自由かつ自動的にアクセスして手間を省きたい
* ブラウザの事情に巻き込まれたくない（更新必須、バージョンが古くて実行できなくなった等）

# 保存機能

* どの本文を閲覧したか
* どのサイトから閲覧したか（URL元）
* いつ閲覧したか
* どこまで閲覧したか（栞）

　上記をIndexedDBで保存する。それをテキストファイルに出力でき、入力もできる。

* 閲覧済み作品一覧（原稿丸ごと圧縮して保存）
	* 表題など一部のメタデータのみ平文で保存

# 本文指摘

　アプリはJavaScriptコードとして公開されるため、自分でアップロードしたサイトでビューアを公開できる。また、誰かが公開したビューアアプリでもいい。これにてURLから本文丸ごと閲覧可能になるし、その中の一部をリンクして表示することもできる。

　JavaScriptのテキストフラグメントでは機能不足。作品のリビジョンと先頭からの文字数で場所を特定する。

　ビューアでなく作品自体を個別のサイトで公開すれば、原稿丸ごとURLに含めずに済む。そこでリビジョンと原稿先頭からの位置を指定すれば、本文中にある特定箇所の範囲指定ができる。

## URL生成

　作品の本文指摘をするURLを生成できる。これにてSNS投稿できる。誤字・脱字・衍字などの指摘、感想など。

　紙媒体であり市販品である本ではできないような共有体験が可能になる。

# 究極の理想

　ユーザは原稿ファイル一つだけで一つの作品を扱える。これをビューアにDnDすれば閲覧できる。原稿は単なるテキストファイルであり、簡単に扱える。ただしファイル末尾にはSQLite3形式バイナリデータを任意に付与することができ、そこに含まれた画像などのバイナリデータを抽出して表示することが可能。

　原稿ファイルはテキストエディタのみで編集可能である。ただしバイナリデータはSQLite3形式として解析する必要がある。

　原稿はファイル共有でもいいし、ブログなどの`<pre>`要素内にテキストを含め、それをコピペして貼り付けてもいい。

* オンライン上で特定のURLにビューアがある。原稿の入力方法は、ファイル、URL、テキスト、の方法があり、それらはIndexedDBで保存することも可能
* ソースコードをダウンロードすれば自分のサイトに掲載可能
* ローカルサーバを立てればローカルで実行可能
* ローカルサーバを立てない`file://`プロトコル版もあるが、機能が限定される
* rustやC言語等で実装されたGUIアプリもある。高速かつ高機能だが実行環境が限定される


# aaaaaaa

1. 現在の画面サイズ等に合わせて適切な文字サイズ等を算出する（一行40字、字間0.05em、行間1.7em等を目安に）
2. 原稿ファイルを読み込む（ファイルパス, URL, `<textarea>`, `string`, IndexedDB, LocalStorage）
3. 1をHTML文字列にパースする（章ごとに分割する。次章に進むたび追加処理する）
4. 3の設定から頁分割計算する（章ごとに分割する。次章に進むたび追加処理する）
5. 動的DOM生成する
6. `display:block/none`で擬似的にページ遷移する
7. IndexedDB等で終了時に現ページを保存し栞とする

HTML|意味
----|----
`<h1>`〜`<h6>`|見出し
`<p>`|パラグラフ
`<br>`|改行（パラグラフ内で用いて意味段落にする）
`　`|インデント。字下げ。段落や意味段落の先頭で行う。
`<em>`|強調。裏の意図を匂わせる。圏点を付与する。
`<ruby>`|読み。または別の読み方を付与する。
`<mark>`|テキスト検索や、URLによる部分指摘などの対象箇所を示す。背景を黄色にする等。
`<strong>`|重要。

* 表紙
	* 題
	* 版
	* 著者
	* 規模（字数）
	* 分類（ジャンル）
* 帯（キャッチコピー、宣伝文句）
* 袖（著者の自己紹介）
* 扉（本扉（最初の頁）、目次扉、中扉（章区切りの先頭）。作品あらすじ、章始めの見開き、前回までのあらすじ、イラスト）
* まえがき（本文へ引き込む役割（期待増幅）、概要説明、挨拶、対象者は誰か、自分の気持ちや考え立場の表明）
* 目次／索引／謝辞／別紙（図表）／人物紹介／相関図／補足情報／付録
* 本文（余白、字間、行間、版面（本文印字領域）、柱（上の余白に章題）、ノンブル（頁数）、段組）
	* 注釈（割注、頭注、脚注、傍注、後注。1),※1,注1,**,*2,（1）,〔1〕,［1］,†1）
* あとがき（作品を締める役割（読了感を味わう）。謝辞、苦労話、自分の気持ちや考え立場の表明）
* 裏表紙（関連出版社、関連作品紹介）

　各頁を意味的に分類すると色々ある。物理的には一画面に収まる領域だが、その内容・意味・役割が違う。

　基本的には最初に見るものほど「要約」である。先に進むほど「詳細」になる。

　何かを期待させるような短いキャッチコピー。それに誘われ手にとり読み進めて期待を満たされる。


英語|用語
----|----
`Cover`|表紙
`backCover`|裏表紙
`band`|帯
`sleeve`|袖
`door`|扉（first-door, middle-door, toc-door）
`toc`|目次(table of contents)
`index`|索引

`title`|題、主題
`sub-title`|副題
`catch-copy`|キャッチコピー、宣伝文句
`logline`|ログライン（作品を一行で要約したもの。誰が、どんな状況で、何をするか）
`synopsis`|シノプシス（あらすじ。主要な出来事の網羅）
`plot`|プロット（本文を書くまえに出来事を起きた順に整理したもの。事実関係を端的に記す）

{kbd ctrl c}
{a https:// 任意テキスト}
{font family:xxxx size:16 color:red text:任意テキスト}


https://note.com/eruetsuryo/n/n1080f7f8f10b

悪を正義と呼ぶ利己を指摘する誠意こそ善である

## 意味分類

　テキストを意味で分類しXML風にしたら。

```xml
<book>
    <split></split><!--画面サイズ、フォントサイズ等を所定値としてページ分割したことを示す-->
    <cover title="" sub="" ver="" rev="" author="" volume="" genre=""></cover><!--表紙-->
    <band><p>キャッチコピー</p></band><!--帯-->
    <intro></intro><!--まえがき、はじめに-->
    <toc></toc><!--目次-->
    <face></face><!--見開き、本扉、中扉-->
    <page></page><!--本文ページ-->
    <page></page>
    <outro></outro><!--あとがき、おわりに-->
    <idx></idx><!--索引-->
    <appendix></appendix><!--付録-->
    <cover></cover><!--裏表紙-->
</book>
```

* 随筆（真っ更）
* 小説（ログライン、シノプシス、プロット、本文）
* 論文（）

# 

# ログライン

## 光の鍛冶師

　結婚して十年になる中堅の鍛冶屋の禿親父は疎遠だった偉大な師匠が突如病死した連絡を受けると共に「最も才能ある弟子に最後の仕事を任せる」との遺言からある仕事を引き継ぐことになる。しかしそれは勇者が魔王退治する最強の剣を作るという無理難題だった。禿親父は凡庸な鍛冶師のため相応しい能力がない。かといって日々のしょぼい仕事だけでは妻子を食わせていくのも厳しくなりつつあり、いよいよ妻から離婚をチラつかされ困窮極まった状況に陥る。あげく他の鍛冶師達は「俺のほうが優秀だ、代わりにやらせろ」と圧をかけられ、街中で「毛ほどの才能もない禿」と揶揄され「無才無毛の禿親父」の二つ名を冠されたことで妻や息子はイジメられ、仕事の依頼も来なくなり、破滅寸前に追い込まれてしまう。

　果たして禿は無事に仕事を成し遂げ信頼を勝ち取り生計を立てていけるのか？　はい、禿は生活を立て直します。なぜなら、かつて師匠から卒業を認められた若かりし頃の作品をみて、鍛冶師をめざした頃の情熱を思い出し、魔を断つ剣を完成させ勇者に納品し、見事魔族に有効打を与えることが実証されたから。これ以来、禿親父の評判はうなぎのぼりで、禿の剣はどれも異様な輝きを放つことから「眩光《げんこう》の禿頭剣《とくとうけん》」の二つ名を冠され、「光の鍛冶師」と呼ばれるようになった。光の勇者との相性も最高で、勇者も禿になるべきだとすら言われ世間が賑わう。妻は良妻賢母ともてはやされ、息子は将来有望とされて女子にモテモテになり、閑古鳥が鳴いていた店は千客万来となり、鍛冶の楽しさを思い出した禿はワクワクした心持ちのまま仕事を受けまくって終わる。

励む男の一本刀、禿夫剣

光の禿夫

　当初は鍛冶の仕事すら失くした彼は、自ら作った武器で魔境へ入り、最強の武器を作る素材を集める。

　禿親父の禿頭から出る特殊な油を塗ることで剣は異様な輝きと切れ味を持つ神剣となる。


